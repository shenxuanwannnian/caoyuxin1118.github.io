{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"JS重修（1）","text":"JS重修1.js是标准Web技术蛋糕的第三层。第一层是HTML，一种标记语言，用来结构化我们的网页内容并赋予内容含义；第二层是CSS一种样式规则语言，将样式应用于HTML内容；第三层是JavaScript一种脚本语言，可以用来创建动态更新的内容，控制多媒体，制作图像动画等等,其核心可以做到： （1）在变量中存储有用的值； （2）操作一段文本； （3）运行代码以响应网页中发生的特定事件等；2.在核心功能之上构建的为API（应用接口程序）——已经建立好的一套代码组件，可以让开发者实现原本很难实现的程序。分为两种： （1）浏览器API。内建于web浏览器中。可以将数据从周边计算机环境中筛选出（每个浏览器标签页相应代码的运行环境，大多数情况下标签页之间完全独立互不影响，保证了其安全性），如DOM API 通过创建，移除和修改HTML，为页面动态应用新样式等手段来操作HTML和CSS；地理位置API 获取地理信息；画布和WebRTC等影音类API 可以对网页进行相关操作； （2） 第三方API。没有默认嵌入浏览器中，需要从网上获得代码和信息，比如Twitter API可以在网站上展示最新推文，意为可以在你的网站上调用相关平台的数据，也可以通过你的网站使用相关平台的一些功能。3.JS是一个轻量级的解释型语言。宿主环境为浏览器时，浏览器接受JavaScript代码，并以代码自身的文本格式运行它。现代的JavaScript转换器运用了即时编译技术，将JS代码编译成为了一种更快的二进制格式，但是这个编译是在程序运行之中发生的。4.服务器端代码 vs 客户端代码 ： 当客户端网页浏览一个网页时，客户端代码就会被下载，然后由浏览器运行并展示，如客户端JS；服务端代码是在服务器上运行，其运行结果由浏览器下载并展示，如PHP,Ruby,JS等等。 一个三层web蛋糕的实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;猜数字游戏&lt;/title&gt; &lt;style&gt; html { font-family: sans-serif } body { width: 50%; max-width: 800px; min-width: 480px; margin: 0 auto } .lastResult { color: white; padding: 3px } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;猜数字游戏&lt;/h1&gt; &lt;p&gt;我刚才随机选定了一个100以内的自然数。看你能否在 10 次以内猜中它。每次我都会告诉你所猜的结果是高了还是低了。&lt;/p&gt; &lt;div class=\"form\"&gt; &lt;label for=\"guessField\"&gt;请猜数: &lt;/label&gt; &lt;input type=\"text\" id=\"guessField\" class=\"guessField\"&gt; &lt;input type=\"submit\" value=\"确定\" class=\"guessSubmit\"&gt; &lt;/div&gt; &lt;div class=\"resultParas\"&gt; &lt;p class=\"guesses\"&gt;&lt;/p&gt; &lt;p class=\"lastResult\"&gt;&lt;/p&gt; &lt;p class=\"lowOrHi\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 开始编写 JavaScript 代码 let randomNumber = Math.floor(Math.random() * 100) + 1; /*获取文档中 class=\"example\" 的第一个元素，三个常量存储着引用，指向HTML段落中的某个元素 设置存储数据的变量和常量以供程序使用 */ const guesses = document.querySelector('.guesses'); const lastResult = document.querySelector('.lastResult'); //猜错提示 const lowOrHi = document.querySelector('.lowOrHi'); //储存表单文本输入和提交按钮的引用，控制之后的猜测提交 const guessSubmit = document.querySelector('.guessSubmit'); const guessField = document.querySelector('.guessField'); let guessCount = 1; //重置按钮 let resetButton; guessField.focus(); function checkGuess() { //将对象的值转化为数字，非数字则返回NaN const userGuess = Number(guessField.value); if(guessCount === 1) { guesses.textContent = '上次猜的数: '; } guesses.textContent += userGuess + ' '; if(userGuess === randomNumber) { lastResult.textContent = '恭喜你！猜对了！'; lastResult.style.backgroundColor = 'green'; lowOrHi.textContent = ''; setGameOver(); } else if(guessCount === 10) { lastResult.textContent = '!!!GAME OVER!!!'; lowOrHi.textContent = ''; setGameOver(); } else { lastResult.textContent = '你猜错了！'; lastResult.style.backgroundColor = 'red'; if(userGuess &lt; randomNumber) { lowOrHi.textContent = '刚才你猜低了！'; } else if(userGuess &gt; randomNumber) { lowOrHi.textContent = '刚才你猜高了！'; } } guessCount++; //清空输入框中的内容以便进行下一次的输入 guessField.value = ''; //对文本域的焦点效果（边框蓝色高亮），只能维持for循环的第一次，每次循环结束要重新赋予 guessField.focus(); } /*将checkGuess事件处理方法附加到html的guessSubmit元素，通过点击运行 只有这一句是运行调用语句 */ guessSubmit.addEventListener('click', checkGuess); function setGameOver() { guessField.disabled = true; guessSubmit.disabled = true; resetButton = document.createElement('button'); resetButton.textContent = '开始新游戏'; //将上面创建的resetButton加入到body的末尾 document.body.appendChild(resetButton); resetButton.addEventListener('click', resetGame); } function resetGame() { guessCount = 1; const resetParas = document.querySelectorAll('.resultParas p'); for(let i = 0 ; i &lt; resetParas.length ; i++) { resetParas[i].textContent = ''; } resetButton.parentNode.removeChild(resetButton); guessField.disabled = false; guessSubmit.disabled = false; guessField.value = ''; guessField.focus(); lastResult.style.backgroundColor = 'white'; randomNumber = Math.floor(Math.random() * 100) + 1; } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2020/01/14/JS重修（1）/"},{"title":"Frank的第一篇文章","text":"从开学，到加入云顶，再到现在，好像除了适应期的时候最干劲十足，到后面就把混在云顶当成了舒适区。落实这个博客是第一步，夯实之前学过的知识，然后慢慢拓展新的知识，把逐渐拓展的事件流当成自己的即使反馈，加油吧！","link":"/2019/08/24/曹宇新的y第一篇文章/"},{"title":"网络协议（1）","text":"通信 三要素：实体，连通，协议。 分类 单工通信，双工通信（半双工，全双工） 单播，多播，广播（可以通知到局域网内的所有主机），主播、 通信的规范格式就是协议：OSI：七层TCP/IP:五层-&gt;四层：应用层&lt;- ：SSH：22 、HTTP：80 、HTTPS：443 、FTP：21传输层&lt;- ：TCP-UDP网络层&lt;- ：IP数据链路 传输层：TCP：安全可靠，相应的传输效率较低，建立了两条管道实现数据传输且实现了全双工。 三次握手（建立连接）：客户端发出请求，服务端回应，客户端确认； 四次挥手（断开连接）：（1）客户端发送结束请求，关闭由客户端到服务器的数据传输（但是还接受服务器向客户端发送的数据）；（2）服务器收到确认请求，发送确认收到请求消息；（3）服务器确认数据传输完成，向客户端发送完成的响应；（4）客户端收到关闭连接响应，再发送确认。服务器没有收到消息客户端重传。服务器收到确认之后即断开连接，客户端等待后没有收到恢复，也断开连接。 UDP：特点相反，非面向连接，但也建立了全双工。在传输的过程中不会保证传输数据的顺序与完整性。应用场景：视频聊天。 应用层：HTTP:（底层协议TCP为全双工，但是只可以实现半双工，因为需要根据请求进行响应） 请求： 请求行： 请求头： 空行： 请求体： 12345GET /a.html HTTP/1.1content-type:application/jsoncokkie:uid=100213;jessionid=hdasdklkajxxxxxx get请求没有请求体，参数在请求头。post不是一定要请求体。 响应： 响应行： 响应头： 空行： 响应体： 12345678HTTP/1.1 200 okset-cookie:a=1;content-type:text/html;content-length:131563152&lt;html&gt; dskdlasd&lt;/html&gt; 小demo实现最基本的处理client端请求功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import java.io.*;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.net.Socket;public class FileServer { // private String address; private int port; private String basePath; public FileServer(String address, int port, String basePath) { this.address = address; this.port = port; this.basePath = basePath; } public void start() throws IOException { //ServerSocket负责接收客户连接请求 ServerSocket serverSocket = new ServerSocket(); /* InetSocketAddress直接继承自java.net.SocketAddress类,根据 IP 地址和端口号生成一个 socket，其把TCP/IP层复杂的操作抽象为简单的接口供应用层调用，以实现进程在网络中的通信。 serverSocket.bind将服务器端需要创建监听特定端口与之前生成的socket进行绑定，相当于特定指向。 先创建后绑定是为了允许服务器在绑定到特定端口之前，先设置ServerSocket的一些选项。一旦绑定，一些选项无法改变 */ serverSocket.bind(new InetSocketAddress(address, port)); System.out.println(\"服务器在\" + port + \"端口启动了,要请求的资源文件在\" + basePath); /* 以上代码搭建完成了最基础的服务器反馈，但是只会反馈一次就结束运行。 此时下方应该设置一个死循环保证服务器可以一直被访问，且要对不同的请求响应不同 */ try { while (true) { System.out.println(\"服务器等待新的请求...\"); //监听，等待连接，一旦有client端连接便创建socket实例 Socket socket = serverSocket.accept(); /* 用来读取数据的管道（输入） getInputStream类是将socket接收到的东西按照字节输入流输入到内存 InputStreamReader类是将字节流转换成字符流 从字符流中读取文本，再建立一个缓冲区实现高效读取 */ BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //用来写出数据的管道 BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); //建立连接后，设置数据传输极限时间 boolean ready = waitForReaderReady(reader); //客户端数据传输失败，结束此连接，进入等待 if (!ready) { socket.close(); continue; } //读取请求行 String requestLine = reader.readLine(); // 读取请求 String line; while((line = reader.readLine())!=null){ System.out.println(line); } String path = requestLine.split(\" \")[1]; System.out.println(\"用户正在请求\" + path + \"路径的文件\"); File file = new File(basePath, path); if (!file.exists()) { System.out.println(\"file not found\"); writer.write(\"HTTP/1.1 404 notfound\\r\\n\"); writer.write(\"content-length:9\\r\\n\"); writer.write(\"\\r\\n\"); writer.write(\"not found\"); //强制刷出缓冲池中的数据,防止文件末尾的数据没有满足缓冲池推出大小，关闭流后丢失 writer.flush(); }else{ InputStream ins = new FileInputStream(file); byte[] buffer = new byte[1024]; writer.write(\"HTTP/1.1 200 OK\\r\\n\"); writer.write(\"content-length\" + file.length() + \"\\r\\n\"); writer.write(\"\\r\\n\"); writer.flush(); int len; while((len = ins.read(buffer)) != -1){ socket.getOutputStream().write(buffer,0,len); } socket.getOutputStream().flush(); } socket.close(); System.out.println(\"请求完成。\"); } } catch (Exception e) { //在命令行打印异常信息在程序中出错的位置及原因 e.printStackTrace(); } } public static void main(String[] args) throws IOException { FileServer fileServer = new FileServer(\"0.0.0.0\", 3000, \"C:/Users/黑红霏霏/Desktop/2019-06-23.png\"); fileServer.start(); } //此函数耗时三分钟执行完毕，完毕之后判断缓冲区是否为空或者底层字符流是否已经准备就绪 private boolean waitForReaderReady(BufferedReader reader) throws IOException, InterruptedException { int retry = 100 * 3; while (retry-- &gt; 0) { if (reader.ready()) { return true; } Thread.sleep(10); } return false; }}","link":"/2019/08/23/hello-world/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"网络协议","slug":"网络协议","link":"/tags/网络协议/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"网络协议","slug":"网络协议","link":"/categories/网络协议/"}]}
{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"JavaScript-ES6（1）","text":"ES6 let命令模块内部不允许用let命令重复声明，存在暂时性死区，不允许变量提升（函数声明和变量声明总是被JavaScript解释器隐式地提升(hoist)到包含他们的作用域的最顶端。)通过创建，初始化，赋值（将声明拆分为三个部分）来对var和let进行区分：对于var来说，在将变量进行赋值之前就已将变量创建并初始化为 undefined，对于let来说，在执行赋值语句之前只进行了创建，在执行语句 的时候会同时进行初始化和赋值，暂时性死区的本质就是不能使用没有初 始化的变量。 模板字符串：会保留排版格式，让反引号内的编译更加友好 123456let title = '云顶书院';let tpl = `&lt;div&gt; &lt;span&gt;${title}&lt;/span&gt;&lt;/div&gt; 没有块级作用域的缺陷： 内层变量可能会覆盖外层变量，计数循环变量可能 泄露为全局变量。两个块级作用域不管是从属还是相互独立let声明的变量都 不会互通 const用法：变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量，则保存此类数据的变量不可再发生改变；对于复合 型类型数（主要为数组或者对象·），变量指向的内存地址只保存指向实际数 据的指针，const会保证此指针不发生改变，但是指向的数据结构可以。 解构将一组变量按照对应位置成批赋值，只要某种数据结构具有 Iterator 接口（即部署了Symbol.iterator属性，该结构不做任何处理就可以被for…of遍历），也可以完成结构，也可以制定默认值，条件是严格的等于undefined数组的解构 123var [a,b,c,d = 'default'] = [1,2,3]; //给d赋予默认值var [a,...c] = [1,2,3]; //a赋值第一个元素，其余值都赋值给c 对象的解构需要对应名称，如果对象中没有相应的属性，被赋值的参数会变undefined 123456789101112131415var obj = { a :1; b :2;}let {a,b} = obj;let {a:A,b} = obj; //赋值给A的方法，此方法a只是传值的过渡，不会在外取到值({a,b} = obj;) //通过解构改变已定义变量的值，需要包裹语句防止解析错误var obj1 = { //复杂解构 arr:[ 'yo', {a : 1,} ]}let{arr:[great,{a}]} = obj1; 其他解构 12345678910let {length} = 'ecw'; //直接得出原型链上的属性let [a,b,c] = 'ecec'; //结构字符串let obj = {b:2}; //解构传参设置默认值function test({a=10;b}){ console.log(a+b);}test(obj); 新增字符串方法 123456console.log('Yo'.includes('Y')); //判断字符串是否包含某个元素，返回布尔值 console.log('Yo'.startsWith('Y')); //判断是否以某一个字符开始console.log('Yo'.endsWith('o')); //判断是否以某一个字符结束 console.log('Yo'.repeat(5)); //某一个字符串的重复次数 Symbol类型 1 Promise对象对比回调函数：由于某些请求有多层嵌套，需要通过上一层逻辑获得的数据来支持下一层逻辑的运行，在ES5中需要多层回调的嵌套来实现，这种方法把执行逻辑的代码和处理结果的代码合在了一起，既增加了代码的复杂度，也降低了代码的利用率，多层嵌套也会导致回调地狱，降低代码的执行效率。所以ES6中，引入了Promise对象来解决这样的回调问题。Promise只负责得到逻辑运行的结果，该结果会在异步操作之后的某一个节点调用（需要以该结果作为支撑的.than或者.catch）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445function test(resolve, reject) { //应用实例var timeOut = Math.random() * 2; //先定义一个函数，并且用到resolve和reject参数setTimeout(function () { if (timeOut &lt; 1) { resolve('200 OK'); } else { reject('timeout in ' + timeOut + ' seconds.'); }}, timeOut * 1000);} var p1 = new Promise(test); //实例化并运行test函数，并将运行的结果赋值给p1var p2 = p1.then(function (result) { //根据p1的结果,如果成功执行此语句console.log('成功：' + result);console.log(\"p2\",p2,p1);});var p3 = p2.catch(function (reason) { //如果p1失败执行此语句console.log('失败：' + reason);console.log(\"p3\",p3,p1);});console.log(\"all\",p2,p3);执行结果为：all Promise { &lt;pending&gt; } Promise { &lt;pending&gt; }成功：200 OKp2 Promise { &lt;pending&gt; } Promise { '200 OK' }或者：失败：timeout in 1.5576485383520353 seconds.p3 Promise { &lt;pending&gt; } Promise { &lt;rejected&gt; 'timeout in 1.5576485383520353 seconds.' }new Promise(function (resolve,reject) { //另一种应用实例 config.query(addSql,parmas,function(err,result) { resolve(result); if(err){ reject(err.message); } console.log(\"添加数据：\", result); }); }); 从上述程序运行结果来看，promise不会改变js原本的异步操作，而会有一种伪同步的感觉。p2,p3也是Promise对象，但是没有相应逻辑会一直处于pending状态。 其他方法 12345Promise.all([p1, p2]).then(function (results) { //并行异步操作，p1，p2全部执行完毕在执行下一步});Promise.race([p1, p2]).then(function (result) { //多个异步提高容错，由于p1执行较快，.then将获得结果'P1'。p2仍在继续执行，但执行结果将被丢弃 }); Proxy在操作目标对象之前架设一层“拦截”，外界对次对象访问都必须要经过这层拦截。Proxy对象就是可以让你去对JavaScript中的一切合法对象的基本操作进行自定义，然后用你自定义的操作去覆盖其对象的基本操作。 123456789101112131415161718192021222324252627282930let p = new Proxy(target,handler); //创建一个proxy对象var obj = { name : 'woainizhingguo'}let newobj = new Proxy(obj,{ //proxy的基本应用 get:function(target,property){ console.log(`您访问了${property}属性`); return target[property]; }})console.log(newobj.name);//也可以直接代理自身，精简代码let handler = { //handler可以独立写出，提高利用率 get: function(target, name){ return name in target ? target[name] : 37; }};let p = new Proxy({}, handler);p.a = 1;p.b = undefined;console.log(p.a, p.b); // 1, undefinedconsole.log('c' in p, p.c); // false, 37","link":"/2020/01/16/JavaScript-ES6（1）/"},{"title":"网络协议（1）","text":"通信 三要素：实体，连通，协议。 分类 单工通信，双工通信（半双工，全双工） 单播，多播，广播（可以通知到局域网内的所有主机），主播、 通信的规范格式就是协议：OSI：七层TCP/IP:五层-&gt;四层：应用层&lt;- ：SSH：22 、HTTP：80 、HTTPS：443 、FTP：21传输层&lt;- ：TCP-UDP网络层&lt;- ：IP数据链路 传输层：TCP：安全可靠，相应的传输效率较低，建立了两条管道实现数据传输且实现了全双工。 三次握手（建立连接）：客户端发出请求，服务端回应，客户端确认； 四次挥手（断开连接）：（1）客户端发送结束请求，关闭由客户端到服务器的数据传输（但是还接受服务器向客户端发送的数据）；（2）服务器收到确认请求，发送确认收到请求消息；（3）服务器确认数据传输完成，向客户端发送完成的响应；（4）客户端收到关闭连接响应，再发送确认。服务器没有收到消息客户端重传。服务器收到确认之后即断开连接，客户端等待后没有收到恢复，也断开连接。 UDP：特点相反，非面向连接，但也建立了全双工。在传输的过程中不会保证传输数据的顺序与完整性。应用场景：视频聊天。 应用层：HTTP:（底层协议TCP为全双工，但是只可以实现半双工，因为需要根据请求进行响应） 请求： 请求行： 请求头： 空行： 请求体： 12345GET /a.html HTTP/1.1content-type:application/jsoncokkie:uid=100213;jessionid=hdasdklkajxxxxxx get请求没有请求体，参数在请求头。post不是一定要请求体。 响应： 响应行： 响应头： 空行： 响应体： 12345678HTTP/1.1 200 okset-cookie:a=1;content-type:text/html;content-length:131563152&lt;html&gt; dskdlasd&lt;/html&gt; 小demo实现最基本的处理client端请求功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import java.io.*;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.net.Socket;public class FileServer { // private String address; private int port; private String basePath; public FileServer(String address, int port, String basePath) { this.address = address; this.port = port; this.basePath = basePath; } public void start() throws IOException { //ServerSocket负责接收客户连接请求 ServerSocket serverSocket = new ServerSocket(); /* InetSocketAddress直接继承自java.net.SocketAddress类,根据 IP 地址和端口号生成一个 socket，其把TCP/IP层复杂的操作抽象为简单的接口供应用层调用，以实现进程在网络中的通信。 serverSocket.bind将服务器端需要创建监听特定端口与之前生成的socket进行绑定，相当于特定指向。 先创建后绑定是为了允许服务器在绑定到特定端口之前，先设置ServerSocket的一些选项。一旦绑定，一些选项无法改变 */ serverSocket.bind(new InetSocketAddress(address, port)); System.out.println(\"服务器在\" + port + \"端口启动了,要请求的资源文件在\" + basePath); /* 以上代码搭建完成了最基础的服务器反馈，但是只会反馈一次就结束运行。 此时下方应该设置一个死循环保证服务器可以一直被访问，且要对不同的请求响应不同 */ try { while (true) { System.out.println(\"服务器等待新的请求...\"); //监听，等待连接，一旦有client端连接便创建socket实例 Socket socket = serverSocket.accept(); /* 用来读取数据的管道（输入） getInputStream类是将socket接收到的东西按照字节输入流输入到内存 InputStreamReader类是将字节流转换成字符流 从字符流中读取文本，再建立一个缓冲区实现高效读取 */ BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //用来写出数据的管道 BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); //建立连接后，设置数据传输极限时间 boolean ready = waitForReaderReady(reader); //客户端数据传输失败，结束此连接，进入等待 if (!ready) { socket.close(); continue; } //读取请求行 String requestLine = reader.readLine(); // 读取请求 String line; while((line = reader.readLine())!=null){ System.out.println(line); } String path = requestLine.split(\" \")[1]; System.out.println(\"用户正在请求\" + path + \"路径的文件\"); File file = new File(basePath, path); if (!file.exists()) { System.out.println(\"file not found\"); writer.write(\"HTTP/1.1 404 notfound\\r\\n\"); writer.write(\"content-length:9\\r\\n\"); writer.write(\"\\r\\n\"); writer.write(\"not found\"); //强制刷出缓冲池中的数据,防止文件末尾的数据没有满足缓冲池推出大小，关闭流后丢失 writer.flush(); }else{ InputStream ins = new FileInputStream(file); byte[] buffer = new byte[1024]; writer.write(\"HTTP/1.1 200 OK\\r\\n\"); writer.write(\"content-length\" + file.length() + \"\\r\\n\"); writer.write(\"\\r\\n\"); writer.flush(); int len; while((len = ins.read(buffer)) != -1){ socket.getOutputStream().write(buffer,0,len); } socket.getOutputStream().flush(); } socket.close(); System.out.println(\"请求完成。\"); } } catch (Exception e) { //在命令行打印异常信息在程序中出错的位置及原因 e.printStackTrace(); } } public static void main(String[] args) throws IOException { FileServer fileServer = new FileServer(\"0.0.0.0\", 3000, \"C:/Users/黑红霏霏/Desktop/2019-06-23.png\"); fileServer.start(); } //此函数耗时三分钟执行完毕，完毕之后判断缓冲区是否为空或者底层字符流是否已经准备就绪 private boolean waitForReaderReady(BufferedReader reader) throws IOException, InterruptedException { int retry = 100 * 3; while (retry-- &gt; 0) { if (reader.ready()) { return true; } Thread.sleep(10); } return false; }}","link":"/2019/08/23/hello-world/"},{"title":"Frank的第一篇文章","text":"从开学，到加入云顶，再到现在，好像除了适应期的时候最干劲十足，到后面就把混在云顶当成了舒适区。落实这个博客是第一步，夯实之前学过的知识，然后慢慢拓展新的知识，把逐渐拓展的事件流当成自己的即使反馈，加油吧！","link":"/2019/08/24/曹宇新的y第一篇文章/"},{"title":"JS重修（1）","text":"JS重修1.js是标准Web技术蛋糕的第三层。第一层是HTML，一种标记语言，用来结构化我们的网页内容并赋予内容含义；第二层是CSS一种样式规则语言，将样式应用于HTML内容；第三层是JavaScript一种脚本语言，可以用来创建动态更新的内容，控制多媒体，制作图像动画等等,其核心可以做到： （1）在变量中存储有用的值； （2）操作一段文本； （3）运行代码以响应网页中发生的特定事件等；2.在核心功能之上构建的为API（应用接口程序）——已经建立好的一套代码组件，可以让开发者实现原本很难实现的程序。分为两种： （1）浏览器API。内建于web浏览器中。可以将数据从周边计算机环境中筛选出（每个浏览器标签页相应代码的运行环境，大多数情况下标签页之间完全独立互不影响，保证了其安全性），如DOM API 通过创建，移除和修改HTML，为页面动态应用新样式等手段来操作HTML和CSS；地理位置API 获取地理信息；画布和WebRTC等影音类API 可以对网页进行相关操作； （2） 第三方API。没有默认嵌入浏览器中，需要从网上获得代码和信息，比如Twitter API可以在网站上展示最新推文，意为可以在你的网站上调用相关平台的数据，也可以通过你的网站使用相关平台的一些功能。3.JS是一个轻量级的解释型语言。宿主环境为浏览器时，浏览器接受JavaScript代码，并以代码自身的文本格式运行它。现代的JavaScript转换器运用了即时编译技术，将JS代码编译成为了一种更快的二进制格式，但是这个编译是在程序运行之中发生的。4.服务器端代码 vs 客户端代码 ： 当客户端网页浏览一个网页时，客户端代码就会被下载，然后由浏览器运行并展示，如客户端JS；服务端代码是在服务器上运行，其运行结果由浏览器下载并展示，如PHP,Ruby,JS等等。 一个三层web蛋糕的实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;猜数字游戏&lt;/title&gt; &lt;style&gt; html { font-family: sans-serif } body { width: 50%; max-width: 800px; min-width: 480px; margin: 0 auto } .lastResult { color: white; padding: 3px } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;猜数字游戏&lt;/h1&gt; &lt;p&gt;我刚才随机选定了一个100以内的自然数。看你能否在 10 次以内猜中它。每次我都会告诉你所猜的结果是高了还是低了。&lt;/p&gt; &lt;div class=\"form\"&gt; &lt;label for=\"guessField\"&gt;请猜数: &lt;/label&gt; &lt;input type=\"text\" id=\"guessField\" class=\"guessField\"&gt; &lt;input type=\"submit\" value=\"确定\" class=\"guessSubmit\"&gt; &lt;/div&gt; &lt;div class=\"resultParas\"&gt; &lt;p class=\"guesses\"&gt;&lt;/p&gt; &lt;p class=\"lastResult\"&gt;&lt;/p&gt; &lt;p class=\"lowOrHi\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 开始编写 JavaScript 代码 let randomNumber = Math.floor(Math.random() * 100) + 1; /*获取文档中 class=\"example\" 的第一个元素，三个常量存储着引用，指向HTML段落中的某个元素 设置存储数据的变量和常量以供程序使用 */ const guesses = document.querySelector('.guesses'); const lastResult = document.querySelector('.lastResult'); //猜错提示 const lowOrHi = document.querySelector('.lowOrHi'); //储存表单文本输入和提交按钮的引用，控制之后的猜测提交 const guessSubmit = document.querySelector('.guessSubmit'); const guessField = document.querySelector('.guessField'); let guessCount = 1; //重置按钮 let resetButton; guessField.focus(); function checkGuess() { //将对象的值转化为数字，非数字则返回NaN const userGuess = Number(guessField.value); if(guessCount === 1) { guesses.textContent = '上次猜的数: '; } guesses.textContent += userGuess + ' '; if(userGuess === randomNumber) { lastResult.textContent = '恭喜你！猜对了！'; lastResult.style.backgroundColor = 'green'; lowOrHi.textContent = ''; setGameOver(); } else if(guessCount === 10) { lastResult.textContent = '!!!GAME OVER!!!'; lowOrHi.textContent = ''; setGameOver(); } else { lastResult.textContent = '你猜错了！'; lastResult.style.backgroundColor = 'red'; if(userGuess &lt; randomNumber) { lowOrHi.textContent = '刚才你猜低了！'; } else if(userGuess &gt; randomNumber) { lowOrHi.textContent = '刚才你猜高了！'; } } guessCount++; //清空输入框中的内容以便进行下一次的输入 guessField.value = ''; //对文本域的焦点效果（边框蓝色高亮），只能维持for循环的第一次，每次循环结束要重新赋予 guessField.focus(); } /*将checkGuess事件处理方法附加到html的guessSubmit元素，通过点击运行 只有这一句是运行调用语句 */ guessSubmit.addEventListener('click', checkGuess); function setGameOver() { guessField.disabled = true; guessSubmit.disabled = true; resetButton = document.createElement('button'); resetButton.textContent = '开始新游戏'; //将上面创建的resetButton加入到body的末尾 document.body.appendChild(resetButton); resetButton.addEventListener('click', resetGame); } function resetGame() { guessCount = 1; const resetParas = document.querySelectorAll('.resultParas p'); for(let i = 0 ; i &lt; resetParas.length ; i++) { resetParas[i].textContent = ''; } resetButton.parentNode.removeChild(resetButton); guessField.disabled = false; guessSubmit.disabled = false; guessField.value = ''; guessField.focus(); lastResult.style.backgroundColor = 'white'; randomNumber = Math.floor(Math.random() * 100) + 1; } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2020/01/14/JS重修（1）/"}],"tags":[{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"网络协议","slug":"网络协议","link":"/tags/网络协议/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"网络协议","slug":"网络协议","link":"/categories/网络协议/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"}]}
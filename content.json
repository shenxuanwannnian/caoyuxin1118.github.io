{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"网络协议（1）","text":"通信 三要素：实体，连通，协议。 分类 单工通信，双工通信（半双工，全双工） 单播，多播，广播（可以通知到局域网内的所有主机），主播、 通信的规范格式就是协议：OSI：七层TCP/IP:五层-&gt;四层：应用层&lt;- ：SSH：22 、HTTP：80 、HTTPS：443 、FTP：21传输层&lt;- ：TCP-UDP网络层&lt;- ：IP数据链路 传输层：TCP：安全可靠，相应的传输效率较低，建立了两条管道实现数据传输且实现了全双工。 三次握手（建立连接）：客户端发出请求，服务端回应，客户端确认； 四次挥手（断开连接）：（1）客户端发送结束请求，关闭由客户端到服务器的数据传输（但是还接受服务器向客户端发送的数据）；（2）服务器收到确认请求，发送确认收到请求消息；（3）服务器确认数据传输完成，向客户端发送完成的响应；（4）客户端收到关闭连接响应，再发送确认。服务器没有收到消息客户端重传。服务器收到确认之后即断开连接，客户端等待后没有收到恢复，也断开连接。 UDP：特点相反，非面向连接，但也建立了全双工。在传输的过程中不会保证传输数据的顺序与完整性。应用场景：视频聊天。 应用层：HTTP:（底层协议TCP为全双工，但是只可以实现半双工，因为需要根据请求进行响应） 请求： 请求行： 请求头： 空行： 请求体： 12345GET /a.html HTTP/1.1content-type:application/jsoncokkie:uid=100213;jessionid=hdasdklkajxxxxxx get请求没有请求体，参数在请求头。post不是一定要请求体。 响应： 响应行： 响应头： 空行： 响应体： 12345678HTTP/1.1 200 okset-cookie:a=1;content-type:text/html;content-length:131563152&lt;html&gt; dskdlasd&lt;/html&gt; 小demo实现最基本的处理client端请求功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import java.io.*;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.net.Socket;public class FileServer { // private String address; private int port; private String basePath; public FileServer(String address, int port, String basePath) { this.address = address; this.port = port; this.basePath = basePath; } public void start() throws IOException { //ServerSocket负责接收客户连接请求 ServerSocket serverSocket = new ServerSocket(); /* InetSocketAddress直接继承自java.net.SocketAddress类,根据 IP 地址和端口号生成一个 socket，其把TCP/IP层复杂的操作抽象为简单的接口供应用层调用，以实现进程在网络中的通信。 serverSocket.bind将服务器端需要创建监听特定端口与之前生成的socket进行绑定，相当于特定指向。 先创建后绑定是为了允许服务器在绑定到特定端口之前，先设置ServerSocket的一些选项。一旦绑定，一些选项无法改变 */ serverSocket.bind(new InetSocketAddress(address, port)); System.out.println(\"服务器在\" + port + \"端口启动了,要请求的资源文件在\" + basePath); /* 以上代码搭建完成了最基础的服务器反馈，但是只会反馈一次就结束运行。 此时下方应该设置一个死循环保证服务器可以一直被访问，且要对不同的请求响应不同 */ try { while (true) { System.out.println(\"服务器等待新的请求...\"); //监听，等待连接，一旦有client端连接便创建socket实例 Socket socket = serverSocket.accept(); /* 用来读取数据的管道（输入） getInputStream类是将socket接收到的东西按照字节输入流输入到内存 InputStreamReader类是将字节流转换成字符流 从字符流中读取文本，再建立一个缓冲区实现高效读取 */ BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //用来写出数据的管道 BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); //建立连接后，设置数据传输极限时间 boolean ready = waitForReaderReady(reader); //客户端数据传输失败，结束此连接，进入等待 if (!ready) { socket.close(); continue; } //读取请求行 String requestLine = reader.readLine(); // 读取请求 String line; while((line = reader.readLine())!=null){ System.out.println(line); } String path = requestLine.split(\" \")[1]; System.out.println(\"用户正在请求\" + path + \"路径的文件\"); File file = new File(basePath, path); if (!file.exists()) { System.out.println(\"file not found\"); writer.write(\"HTTP/1.1 404 notfound\\r\\n\"); writer.write(\"content-length:9\\r\\n\"); writer.write(\"\\r\\n\"); writer.write(\"not found\"); //强制刷出缓冲池中的数据,防止文件末尾的数据没有满足缓冲池推出大小，关闭流后丢失 writer.flush(); }else{ InputStream ins = new FileInputStream(file); byte[] buffer = new byte[1024]; writer.write(\"HTTP/1.1 200 OK\\r\\n\"); writer.write(\"content-length\" + file.length() + \"\\r\\n\"); writer.write(\"\\r\\n\"); writer.flush(); int len; while((len = ins.read(buffer)) != -1){ socket.getOutputStream().write(buffer,0,len); } socket.getOutputStream().flush(); } socket.close(); System.out.println(\"请求完成。\"); } } catch (Exception e) { //在命令行打印异常信息在程序中出错的位置及原因 e.printStackTrace(); } } public static void main(String[] args) throws IOException { FileServer fileServer = new FileServer(\"0.0.0.0\", 3000, \"C:/Users/黑红霏霏/Desktop/2019-06-23.png\"); fileServer.start(); } //此函数耗时三分钟执行完毕，完毕之后判断缓冲区是否为空或者底层字符流是否已经准备就绪 private boolean waitForReaderReady(BufferedReader reader) throws IOException, InterruptedException { int retry = 100 * 3; while (retry-- &gt; 0) { if (reader.ready()) { return true; } Thread.sleep(10); } return false; }}","link":"/2019/08/23/hello-world/"},{"title":"Frank的第一篇文章","text":"从开学，到加入云顶，再到现在，好像除了适应期的时候最干劲十足，到后面就把混在云顶当成了舒适区。落实这个博客是第一步，夯实之前学过的知识，然后慢慢拓展新的知识，把逐渐拓展的事件流当成自己的即使反馈，加油吧！","link":"/2019/08/24/曹宇新的y第一篇文章/"}],"tags":[{"name":"网络协议","slug":"网络协议","link":"/tags/网络协议/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"网络协议","slug":"网络协议","link":"/categories/网络协议/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"}]}